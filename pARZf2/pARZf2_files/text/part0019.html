<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>

    <title>第13章　子Shell与进程处理</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>

  


<link href="../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet" />

</head>
<body>

<div class="calibreMeta">
  <div class="calibreMetaTitle">
  
  
    
    <h1>
      <a href="../../pARZf2.html">Shell从入门到精通
</a>
    </h1>
    
    
  
  </div>
  <div class="calibreMetaAuthor">
    张春晓

  </div>
</div>

<div class="calibreMain">

  <div class="calibreEbookContent">
    
      <div class="calibreEbNavTop">
        
          <a href="part0018.html" class="calibreAPrev">previous page</a>
        

        
          <a href="part0020.html" class="calibreANext"> next page</a>
        
      </div>
    

    
    <div class="chapter">
      <div class="calibre2"></div><h1 class="kindle-cn-heading" id="chapter313"><a href="part0004.html#toc313" class="calibre3">第13章<br class="chapter"/>子Shell与进程处理</a>
      </h1>
      <p class="kindle-cn-para-left">当用户在命令行中执行一个Shell脚本的时候，会感觉到Shell脚本就是在当前的命令行提示符下被解释的。实际上，其过程并不是用户看到的那样，在脚本被执行的时候，当前的Shell会启动另外一个Shell实例，这样的话，每个Shell脚本都有效地运行在父Shell的一个子进程中。在进行Shell编程的时候，不可避免地会遇到处理子Shell和父Shell的关系，以及进程和作业的控制，本章将对子Shell和进程处理进行介绍。</p>
      <p class="kindle-cn-para-left">本章主要涉及的知识点如下所述。</p>
      <ul class="kindle-cn-ul-square">
        <li class="calibre5">子Shell：主要介绍子Shell的相关知识，包括Shell内部命令、外部命令、圆括号命令，以及子Shell中的变量的作用域等。</li>
        <li class="calibre5">进程处理：主要介绍进程和作业的控制，包括什么是进程、通过Shell脚本管理进程、作业控制、信号，以及trap命令等。</li>
      </ul>
      <h2 class="kindle-cn-heading1" id="sub314"><a href="part0004.html#toc314" class="calibre8">13.1　子Shell</a>
      </h2>
<p class="kindle-cn-para-left">Shell本身也是一个程序，也可以启动自己的子进程，这些子进程称为子Shell。作为初学者，必须搞清楚子Shell与其父Shell的区别与联系，以及Shell命令与子Shell的关系。本节将对子Shell的基础知识进行介绍。</p>
      <h3 class="kindle-cn-heading2" id="sub315"><a href="part0004.html#toc315" class="calibre8">13.1.1　什么是子Shell</a>
      </h3>
      <p class="kindle-cn-para-left">当用户登录Linux或者UNIX之后，操作系统会根据用户/etcpasswd文件中的配置启动一个Shell进程，该Shell进程为当前用户所执行的Shell命令的父进程。每个用户都可以指定自己的默认Shell程序，下面显示的是/etc/passwd文件的部分内容：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# cat /etc/passwd</span>
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
…
</pre>
</div>
      <p class="kindle-cn-para-left">从上面的内容可以得知，/etc/passwd每一行描述的是一个用户的信息，每一行由7个字段组成，这些字段之间用分号隔开。7个字段的涵义如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">登录名 :x: 用户 ID: 用户组 ID: 备注信息 : 用户主目录 : 默认 Shell 程序  	
</pre>
</div>
<p class="kindle-cn-para-left">其中，默认Shell程序在第7个字段定义，并且使用绝对路径表示。如果这个字段的Shell程序不存在、不合法或者执行失败，则无法登录主机。如果某个用户不需要登录，则可以将该用户的默认的Shell程序设置为/sbin/nologin。</p>
      <p class="kindle-cn-para-left">当用户在执行一个Shell脚本的时候，父Shell会根据脚本程序的第1行#!符号后面指定的解释器程序开启一个子Shell进程，然后在子Shell的环境中执行该Shell脚本。一旦子Shell中的脚本执行完毕，该子Shell进程随即结束，并且返回到父Shell中。这个过程不会影响父Shell中的环境。</p>
      <p class="kindle-cn-para-left">所谓子Shell，实际上是父Shell的一个子进程。子Shell本身也可以创建自己的子进程，从而成为其子进程的父Shell。从定义可以看出，父Shell和子Shell都是相对的。某个Shell可以成为一个Shell的父Shell，也可以同时成为另外一个Shell的子Shell，反之亦然。在环境变量，以及标准输入、标准输出和标准错误等方面，父Shell和子Shell是相同的。</p>
      <p class="kindle-cn-para-left">【<span class="kindle-cn-bold">例13-1</span>】演示子Shell与父Shell的关系，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">01   #----------------------------/chapter13/ex13-1.sh------------------
02   #! /bin/bash
03
04   # 改变工作目录
05   cd /var/log
06   # 打印当前工作目录
07   pwd
</pre>
</div>
      <p class="kindle-cn-para-left">在上面的代码中，第5行通过cd命令改变当前的工作目录，第7行通过pwd命令打印当前的工作目录。</p>
      <p class="kindle-cn-para-left">该程序的执行结果如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# ./ex13-1.sh</span>
/var/log
[root@linux chapter13]#
</pre>
</div>
      <p class="kindle-cn-para-left">从上面的执行结果可以得知，当执行ex13-1.sh时，Shell会创建一个子Shell，子Shell和父Shell是相对独立的。用户在脚本中执行的Shell命令并不会影响到父Shell，例如第5行代码的cd命令在子Shell中改变当前的工作目录，当子Shell退出之后，父Shell当前的工作目录不受影响。</p>
      <p class="kindle-cn-para-left">如果用户想要在当前的Shell中执行脚本，则可以使用圆点命令，如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# . ./ex13-1.sh</span>
/var/log
[root@linux log]# pwd
/var/log
</pre>
</div>
<p class="kindle-cn-para-left">从上面的执行结果可以得知，使用圆点命令在当前的Shell中执行脚本，会影响到当前Shell环境。在上面的例子中，当前Shell的工作目录已经被切换到/var/log。</p>
      <p class="kindle-cn-para-hang"><img class="kindle-cn-inline-image1" alt="img" src="../images/00005.jpeg"/><span class="kindle-cn-bold">注意：</span><span class="cnother">圆点命令与脚本文件名之间有一个空格。</span></p>
      <h3 class="kindle-cn-heading2" id="sub316"><a href="part0004.html#toc316" class="calibre8">13.1.2　内部命令、保留字和外部命令</a>
      </h3>
      <p class="kindle-cn-para-left">Shell命令分为内部命令和外部命令。所谓内部命令，是指包含在Shell工具包中的命令，内部命令是Shell本身的重要组成部分。内部命令嵌入在Shell程序中，并不单独以磁盘文件的形式存在于磁盘上。例如cd、bg，以及fg等命令都是bash Shell的内部命令。如表13-1所示，列出了bash Shell中常用的内部命令。</p>
<p class="kindle-cn-caption"><span class="kindle-cn-bold">表13-1　bash Shell常用的内部命令</span></p>
<table cellspacing="0" class="kindle-cn-table-body">
        <tr class="calibre13">
          <td class="kindle-cn-table-th">内部命令</td>
          <td class="kindle-cn-table-th1">说　明</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">.</td>
          <td class="kindle-cn-table-dg">读取Shell脚本，并在当前Shell中执行脚本</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">alias</td>
          <td class="kindle-cn-table-dg">设置命令别名</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">bg</td>
          <td class="kindle-cn-table-dg">将作业置于后台运行</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">cd</td>
          <td class="kindle-cn-table-dg">改变当前工作目录</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">echo</td>
          <td class="kindle-cn-table-dg">打印指定的文本</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">eval</td>
          <td class="kindle-cn-table-dg">将参数作为Shell命令执行</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">exec</td>
          <td class="kindle-cn-table-dg">以特定的程序取代Shell或者改变当前Shell的输出输入</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">exit</td>
          <td class="kindle-cn-table-dg">退出Shell</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">export</td>
          <td class="kindle-cn-table-dg">将变量声明为环境变量</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">fc</td>
          <td class="kindle-cn-table-dg">与命令历史一起运行</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">fg</td>
          <td class="kindle-cn-table-dg">将作业置于前台运行</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">getopts</td>
          <td class="kindle-cn-table-dg">处理命令行选项</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">history</td>
          <td class="kindle-cn-table-dg">显示命令历史</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">jobs</td>
          <td class="kindle-cn-table-dg">显示在后台运行的作业</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">kill</td>
          <td class="kindle-cn-table-dg">向进程发送信号</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">logout</td>
          <td class="kindle-cn-table-dg">从Shell中注销</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">pwd</td>
          <td class="kindle-cn-table-dg">显示当前的工作目录</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">set</td>
          <td class="kindle-cn-table-dg">设置Shell环境变量</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">shift</td>
          <td class="kindle-cn-table-dg">变换命令行参数</td>
        </tr>
      </table>
      <p class="kindle-cn-para-left">内部命令实际上是Shell程序的一部分，其中包含的是一些比较简练的Linux系统命令，这些命令由Shell程序识别并在Shell程序内部完成运行，通常在加载用户的默认Shell时就被加载并驻留在系统内存中。</p>
      <p class="kindle-cn-para-left">除了内部命令之外，还有一部分保留字也是Shell的重要组成部分，例如if、for、then，以及while等都是bash Shell的内置关键字。保留字不是Shell命令，通常用在Shell脚本中，组成Shell脚本的基本语法结构。如表13-2所示，列出了bash Shell中常用的保留字。</p>
<p class="kindle-cn-caption"><span class="kindle-cn-bold">表13-2　bash Shell中常用的保留字</span></p>
<table cellspacing="0" class="kindle-cn-table-body">
        <tr class="calibre13">
          <td class="kindle-cn-table-th">保留字</td>
          <td class="kindle-cn-table-th1">说　明</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">!</td>
          <td class="kindle-cn-table-dg">逻辑非</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">:</td>
          <td class="kindle-cn-table-dg">空命令</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">break</td>
          <td class="kindle-cn-table-dg">跳出for、while，以及until循环结构</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">case</td>
          <td class="kindle-cn-table-dg">多重条件判断</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">continue</td>
          <td class="kindle-cn-table-dg">跳过for、while、until，以及select等结构中后面的语句，从头开始执行下一次循环</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">declare</td>
          <td class="kindle-cn-table-dg">声明并定义变量属性</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">do</td>
          <td class="kindle-cn-table-dg">语句块的定义，常用于for、while、until，以及select等循环结构中</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">done</td>
          <td class="kindle-cn-table-dg">语句块的定义，常用于for、while、until，以及select等循环结构中</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">elif</td>
          <td class="kindle-cn-table-dg">if条件判断结构中的分支语句</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">else</td>
          <td class="kindle-cn-table-dg">if条件判断结构中的分支语句</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">esac</td>
          <td class="kindle-cn-table-dg">case多条件分支结构的结束语句</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">for</td>
          <td class="kindle-cn-table-dg">循环语句</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">let</td>
          <td class="kindle-cn-table-dg">执行算术运算</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">local</td>
          <td class="kindle-cn-table-dg">定义局部变量</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">read</td>
          <td class="kindle-cn-table-dg">从标准输入读取一行数据</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">return</td>
          <td class="kindle-cn-table-dg">从函数或者脚本返回</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">test</td>
          <td class="kindle-cn-table-dg">条件测试</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">then</td>
          <td class="kindle-cn-table-dg">if条件判断结构中的关键字</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">until</td>
          <td class="kindle-cn-table-dg">循环语句</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">wait</td>
          <td class="kindle-cn-table-dg">等待后台作业完成</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">while</td>
          <td class="kindle-cn-table-dg">循环语句</td>
        </tr>
      </table>
<p class="kindle-cn-para-left">外部命令是Linux系统中的实用程序部分，这些实用程序以磁盘文件的形式存在于磁盘中。在用户登录时，外部命令并不随着默认Shell的载入被加载到内存中，而是在需要的时候才被调进内存。</p>
      <p class="kindle-cn-para-left">尽管外部命令的代码不包含在Shell程序中，但是其命令执行过程则是由Shell程序控制的。Shell程序管理外部命令执行时的路径查找和代码加载，并控制命令的执行。</p>
      <p class="kindle-cn-para-left">绝大部分的Shell命令都是外部命令，例如ls、at、du、host，以及id等。外部命令通常位于/usr/bin及/usr/sbin等目录中，其中/usr/sbin中的命令通常与系统管理有关。</p>
<p class="kindle-cn-para-left">由于内部命令的代码嵌入到Shell程序中，所以当用户执行内部命令，Shell并不需要创建子Shell，而是由当前的Shell程序直接解释并执行。而外部命令则是由当前的Shell程序创建一个子Shell，然后在子Shell环境中执行的。当命令执行完成之后，子Shell退出，并返回到父Shell中。</p>
      <p class="kindle-cn-para-left">【<span class="kindle-cn-bold">例13-2</span>】说明Shell在执行外部命令时的过程，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">01   #----------------------------/chapter13/ex13-2.sh------------------
02   #! /bin/bash
03
04   # 查找包含 ps 字符串的进程
05   ps -ef|grep ps
06   # 显示当前 Shell 的层次
07   echo $SHLVL
08   # 查找执行 ex13-2.sh 脚本的 Shell 进程的 ID
09   pidof -x ex13-2.sh
10
11   exit 0
</pre>
</div>
<p class="kindle-cn-para-left">在上面的代码中，第5行通过ps命令、管道，以及grep命令来查找含有字符串ps的进程列表。第7行使用系统变量$SHLVL来输出当前Shell的层次，该层次以用户的登录Shell为第1层。第9行使用pidof命令获取执行脚本ex13-2.sh的子Shell的进程ID。</p>
      <p class="kindle-cn-para-left">该程序的执行结果如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# ./ex13-2.sh</span>
…
root    4958    4957    1       23:50   pts/0    00:00:00       ps -ef
root     4959    4957    0       23:50   pts/0    00:00:00       grep ps
…
2
4957
</pre>
</div>
      <p class="kindle-cn-para-left">在上面的输出结果中，最开始的表格是第4行代码的ps命令输出的，一共有8列，分别是进程的所有者、进程ID、父进程ID、CPU使用率、进程启动时间、终端号、进程使用CPU累计时间，以及所执行的命令。在此，我们比较关注进程的ID和父进程ID。在上面的输出结果中，执行命令ps-ef的进程ID为4958，其父进程ID为4957。在接下来第7行代码的echo语句输出当前Shell的层次为2，这意味着脚本是在登录Shell的子Shell中执行。最后，pidof命令的输出结果为4957，即执行脚本的子Shell的进程ID为4957。</p>
<p class="kindle-cn-para-left">有了上面的结果之后，我们再进一步分析一下【例13-2】的脚本执行的整个过程。首先，无论是ps还是grep命令，都是外部命令，所以Shell会为这两个命令创建子Shell来执行。而这两个子Shell的进程ID分别为4958和4959。另外，脚本ex13-2.sh本身也是在用户登录Shell的子Shell中执行的，这个子Shell的进程ID即pidof命令的输出结果，即4957。而这个进程ID恰好是登录Shell的子Shell的进程ID。因此，【例13-2】中的Shell之间的关系如图13-1所示。</p>
      <div class="chapter">
        <div class="kindle-cn-image">
          <p class="kindle-cn-para-center">
            <img alt="alt1041" src="../images/00068.jpeg" class="calibre18"/>
          </p>
          <p class="kindle-cn-caption">图13-1　【例13-2】中的子Shell之间的关系</p>
        </div>
      </div>
      <h3 class="kindle-cn-heading2" id="sub317"><a href="part0004.html#toc317" class="calibre8">13.1.3　在子Shell中执行命令</a>
      </h3>
<p class="kindle-cn-para-left">接下来讨论一下在哪些情况下Shell会在子Shell中执行命令。实际上，不同的Shell可能会以不同的方式来执行命令。但是，在bash Shell中，以下几种情况通常会使Shell在其子Shell中执行命令。</p>
      <p class="kindle-cn-para-left"><span class="kindle-cn-bold">1．圆括号结构</span></p>
      <p class="kindle-cn-para-left">当一组命令放在圆括号中时，该组命令会在一个子Shell环境中执行，其语法如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">(command1;command2;command3;...)
</pre>
</div>
      <p class="kindle-cn-para-left">在上面的语法中，command1、command2，以及command3等都是Shell命令，这些命令写在一行中，它们之间用分号隔开。</p>
      <p class="kindle-cn-para-left">如果每一行只有一条命令，则可以省略分号，变成以下语法形式：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">(
   command1
   command2
   command3
   ...
)
</pre>
</div>
      <p class="kindle-cn-para-left">【<span class="kindle-cn-bold">例13-3</span>】演示圆括号结构的使用方法，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">01   #----------------------------/chapter13/ex13-3.sh------------------
02   #!/bin/bash
03
04   echo
05   # 输出子 Shell 的层次
06   echo "Subshell level OUTSIDE subshell = $BASH_SUBSHELL"
07
08   echo
09   # 定义子 Shell 外面的变量
10   outer_variable=Outer
11   # 圆括号开始
12   (
13      # 输出子 Shell 的层次
14      echo "Subshell level INSIDE subshell = $BASH_SUBSHELL"
15      # 定义子 Shell 内的变量
16      inner_variable=Inner
17      # 在子 Shell 内输出圆括号里面定义的变量
18      echo "From subshell, \"inner_variable\" = $inner_variable"
19      # 在子 Shell 内输出圆括号外面定义的变量
20      echo "From subshell, \"outer\" = $outer_variable"
21   )
22
23   echo
24   # 输出子 Shell 级别
25   echo "Subshell level OUTSIDE subshell = $BASH_SUBSHELL"
26   echo
27   # 判断 inner_variable 变量是否已经定义
28   if [ -z "$inner_variable" ]
29   then
30     echo "inner_variable undefined in main body of shell"
31   else
32     echo "inner_variable defined in main body of shell"
33   fi
34   # 输出圆括号内定义的变量
35   echo "From main body of shell, \"inner_variable\" = $inner_variable"
</pre>
</div>
<p class="kindle-cn-para-left">在上面的代码中，第6行使用系统变量BASH_SUBSHELL获取当前子Shell的层次。如果当前环境为用户登录时默认的Shell，则该变量的值为0。第10行在圆括号结构外面定义了一个变量outer_variable，并且赋予了初始值。第12～21行是圆括号结构，其中包含4条语句。第14行在圆括号内部输出子Shell的层次。第16行定义了另外一个变量inner_variable。第18行输出变量inner_variable的值，第20行输出变量outer_variable的值。</p>
<p class="kindle-cn-para-left">第25行重新在圆括号结构外面输出当前子Shell的层次。第28～33行判断变量$inner_variable是否已经被定义，并且根据不同的情况输出不同的消息。第35行输出圆括号结构内定义的变量inner_variable的值。</p>
      <p class="kindle-cn-para-left">该程序的执行结果如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# ./ex13-3.sh</span>
Subshell level OUTSIDE subshell = 0
Subshell level INSIDE subshell = 1
From subshell, "inner_variable" = Inner
From subshell, "outer" = Outer
Subshell level OUTSIDE subshell = 0
inner_variable undefined in main body of shell
From main body of shell, "inner_variable" =
</pre>
</div>
      <p class="kindle-cn-para-left">在上面的输出结果中，可以发现代码第6行的echo语句的输出结果为0，表示当前处于最顶层的子Shell中。而代码第14行的echo语句的输出结果为1，表示当前子Shell的层次为1。代码第18行和第20行的echo语句分别输出了圆括号外面和内部定义的两个变量值。从上面的执行结果可以得知，子Shell中可以访问父Shell中定义的变量的值。代码第25行的echo语句的输出结果为0，表示程序已经退出子Shell。最后，在子Shell中定义的变量不能在父Shell中访问。</p>
<p class="kindle-cn-para-left">由于圆括号结构中的命令都是在一个子Shell中执行的，与调用另外一个脚本中的代码非常相似，所以通过圆括号结构，用户可以将Shell程序中的某一段代码放在后台执行，其实现方法就是在圆括号结构的后面使用&amp;操作符。</p>
      <p class="kindle-cn-para-left">【<span class="kindle-cn-bold">例13-4</span>】演示将脚本中的部分代码放在后台执行的方法，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">01   #----------------------------/chapter13/ex13-4.sh------------------
02   #!/bin/bash
03
04   # 输出开始提示信息
05   echo "Before starting subshell"
06   # 圆括号结构开始
07   (
08      count=1
09      while [ $count -le 10 ]
10      do
11          echo "$count"
12          sleep 1
13          # 在 Shell 中修改循环变量的值
14          (( count++ ))
15      done
16   ) &amp;
17   echo "Finished"
</pre>
</div>
      <p class="kindle-cn-para-left">在上面的代码中，第7～16行是整个圆括号结构。第8行定义了循环变量count，并且赋予初始值1。第9行是while循环结构的开始，其循环条件为变量count的值小于等于10。第11行输出循环变量的值，第12行使得当前的进程睡眠1秒钟。第14行又是另外一个嵌套两层的圆括号结构，在该结构中执行循环变量的自增。第16行使用&amp;操作符将整个圆括号结构置于后台执行。</p>
      <p class="kindle-cn-para-left">该程序的执行结果如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# ./ex13-4.sh</span>
Before starting subshell
Finished
1
[root@linux chapter13]# 2
3
4
5
6
7
8
9
10
</pre>
</div>
<p class="kindle-cn-para-left">当用户输入以上命令执行ex13-4.sh的时候，当前的Shell会创建一个子进程来执行脚本文件。代码第5行的echo语句输出了一条信息。当遇到圆括号及&amp;操作符的时候，Shell会将其中的命令放在另外一个子Shell中并且作为后台作业执行。此时，执行脚本文件的子进程和圆括号中的代码是并行地执行的。所以执行脚本ex13-4.sh的子进程继续执行圆括号后面的代码，即代码第17行的echo语句输出另外一条信息。此时，正在后台执行的圆括号中的代码输出了循环变量的值1。</p>
      <p class="kindle-cn-para-left">执行脚本的子进程在执行完代码第17行的echo语句后退出，返回到命令提示符。而圆括号中的代码却仍然在执行，依次输出了2～10的值。</p>
      <p class="kindle-cn-para-left">通过上面的例子可以得知，子Shell中的代码可以访问父Shell中的变量的值。并且，当变量的值在子Shell中修改之后，在父Shell中可以获得变化之后的值。</p>
      <p class="kindle-cn-para-hang"><img class="kindle-cn-inline-image1" alt="img" src="../images/00005.jpeg"/><span class="kindle-cn-bold">注意：</span><span class="cnother">在【例13-4】中第14行的语句使用了两层圆括号，所以会导致产生两层子Shell。</span></p>
      <p class="kindle-cn-para-left"><span class="kindle-cn-bold">2．后台执行或异步执行</span></p>
      <p class="kindle-cn-para-left">在某些情况下，Shell命令需要较长的时间来执行，尤其是在处理大量的数据的时候。在这种情况下，用户可以将命令置于后台执行，而不必等待命令执行结束。</p>
      <p class="kindle-cn-para-left">将命令置于后台执行的语法如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">command&amp;
</pre>
</div>
<p class="kindle-cn-para-left">其中，command表示要执行的命令，&amp;操作符表示将前面的命令置于后台执行。在命令末尾追加&amp;操作符之后，当前命令会由一个子Shell在后台执行。当前的Shell会立即获得控制权并且返回到命令行提示符。后台命令和当前的Shell是并行的，相互之间没有依赖及等待关系。这意味着，后台命令和当前Shell是异步的并行。</p>
      <p class="kindle-cn-para-left">用户可以在任何一个Shell命令后面使用&amp;操作符，将该命令置于后台运行。关于&amp;操作符的例子，在上面的【例13-4】中已经介绍过了，此处不再详细说明。</p>
      <p class="kindle-cn-para-left"><span class="kindle-cn-bold">3．命令替换</span></p>
      <p class="kindle-cn-para-left">命令替换的语法如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">'command'
</pre>
</div>
      <p class="kindle-cn-para-left">或者</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">$(command)
</pre>
</div>
      <p class="kindle-cn-para-left">其中，command表示要执行的命令。command会在一个子Shell中执行，不会影响当前的Shell环境。</p>
      <p class="kindle-cn-para-left">【<span class="kindle-cn-bold">例13-5</span>】演示使用命令替换在子Shell中执行命令，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">01   #----------------------------/chapter13/ex13-5.sh------------------
02   #! /bin/bash
03
04   # 在子 Shell 中执行命令，并且返回结果
05   $(cd /;ls;echo "current working directory is ";pwd)
06
07   echo "current working directory is"
08
09   # 在父 Shell 中输出当前工作目录
10   pwd
</pre>
    </div>
      <p class="kindle-cn-para-left">在上面的代码中，第5行使用$()符号执行一组Shell命令，这些命令之间用分号隔开，第1个命令为cd，将子Shell的当前工作目录切换到根目录；第2个命令为echo，用来输出一行提示信息；第3个命令为pwd，输出当前工作目录。第10行在父Shell中输出当前的工作目录。</p>
      <p class="kindle-cn-para-left">该程序的执行结果如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# ./ex13-5.sh</span>
bin      data2           etc                   lib64       mnt  root    sys
boot     data_.base.tar  home                lost+found  net  sbin    tmp
cgroup  demo.sh         ImagedTabSet.css   media       opt  selinux usr
data1    dev              lib                 misc         proc srv    var
current working directory is
/
current working directory is
/root/chapter13
</pre>
</div>
      <p class="kindle-cn-para-left">从上面的执行结果可以得知，子Shell中的cd命令只会改变子Shell的工作目录，并不影响父Shell的环境，因此，在上面的例子中，父Shell的工作目录仍然为/root/chapter13，并没有切换到根目录。</p>
<p class="kindle-cn-para-left">除了以上两种在子Shell中执行命令的方法之外，还有其他一些方法，例如管道以及进程替换等。在不同的Shell中，对于管道和进程替换的处理方法会有所不同，读者可以参考相关的书籍，不再详细介绍。</p>
      <h3 class="kindle-cn-heading2" id="sub318"><a href="part0004.html#toc318" class="calibre8">13.1.4　把子Shell中的变量值传回父Shell</a>
      </h3>
<p class="kindle-cn-para-left">在子Shell中，代码可以访问父Shell的变量；反之，在父Shell中，无法访问到子Shell中的变量的值。但是，用户可以通过一些变通的技巧来取得子Shell中的变量的值。下面将分别进行介绍。</p>
      <p class="kindle-cn-para-left"><span class="kindle-cn-bold">1．通过临时文件</span></p>
      <p class="kindle-cn-para-left">在Linux中，通过临时文件传递数据是一个非常重要的技巧，许多地方都能使用到。对于磁盘文件来说，只要拥有足够的权限，任何进程都可以访问到。另外，通过临时文件，用户可以在进程之间传递大量的数据，不会受到内存空间的限制。</p>
      <p class="kindle-cn-para-left">【<span class="kindle-cn-bold">例13-6</span>】演示通过临时文件在父子Shell之间传递数据，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">01   #----------------------------/chapter13/ex13-6.sh------------------
02   #! /bin/bash
03
04   (
05      # 在子 Shell 中定义变量 x
06      x=500
07      # 将变量 x 的值输出到临时文件 tmp
08      echo "$x" &gt;tmp
09   )
10
11   # 在父 Shell 中直接引用变量 x 的值
12   echo "$x"
13   # 从临时文件中读取变量 x 的值
14   read b &lt;tmp
15
16   echo "$b"
</pre>
</div>
      <p class="kindle-cn-para-left">在上面的代码中，第4～9行是圆括号结构，将在子Shell中执行。第6行定义了一个名称为x的变量，第8行将变量x的值通过重定向输出到临时文件tmp中。第12行在父Shell中直接引用变量x的值。第14行通过read语句从临时文件中读取变量x的值。</p>
      <p class="kindle-cn-para-left">该程序的执行结果如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# ./ex13-6.sh</span>
500
</pre>
</div>
      <p class="kindle-cn-para-left">从上面的执行结果可以得知，第12行的echo语句的输出为空串。而第16行的echo语句正确输出了变量x的值。</p>
      <p class="kindle-cn-para-left"><span class="kindle-cn-bold">2．使用命名管道</span></p>
      <p class="kindle-cn-para-left">命名管道是Linux及UNIX系统中的最古老的进程间通信的方式，同时也是一个相对比较简单的通信机制。</p>
      <p class="kindle-cn-para-left">【<span class="kindle-cn-bold">例13-7</span>】演示使用命名管道实现向父shell传递数据的方法，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">01   #----------------------------/chapter13/ex13-7.sh------------------
02   #! /bin/bash
03
04   # 创建名称为 fifo 的命名管道
05   if [ ! -e fifo ];then
06      mkfifo fifo
07   fi
08
09   # 子 Shell
10   (
11      x=500
12      # 将变量 x 的值输出到管道
13      echo "$x" &gt; fifo
14   )&amp;
15   # 从管道中读取数据
16   read y &lt;fifo
17
18   echo "$y"
</pre>
</div>
      <p class="kindle-cn-para-left">在上面的代码中，第5～7行判断命名管道fifo是否存在，如果不存在，则创建该管道。第10～14行是圆括号结构，并且在圆括号后面使用了&amp;操作符将该结构放在后台运行。第16行从命名管道fifo中读取数据。</p>
      <p class="kindle-cn-para-left">该程序的执行结果如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# ./ex13-7.sh</span>
500
</pre>
</div>
      <p class="kindle-cn-para-left"><span class="kindle-cn-bold">3．不使用子Shell</span></p>
<p class="kindle-cn-para-left">之所以出现以上变量传递问题，是因为使用了子Shell。如果不使用子Shell，则以上问题就不存在。当用户在某个Shell脚本中调用另外一个脚本时，被调用的脚本会在子Shell中执行。但是，用户可以通过圆点命令和source命令来执行脚本，使得被调用的脚本在当前Shell进程中执行。</p>
      <p class="kindle-cn-para-left">【<span class="kindle-cn-bold">例13-8</span>】演示两个脚本之间传递数据的方法，其中output.sh的代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">01   #----------------------------/chapter13/output.sh------------------
02   #! /bin/bash
03
04   # 输出变量 message 的值
05   echo "$message"
</pre>
</div>
      <p class="kindle-cn-para-left">从上面的代码可以得知，output.sh的功能非常简单，只是输出变量message的值。但是变量message并没有在当前脚本中定义。</p>
      <p class="kindle-cn-para-left">脚本ex13-8.sh的代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">01   #----------------------------/chapter13/ex13-8.sh------------------
02   #! /bin/bash
03
04   # 定义变量 message ，并赋予初始值
05   message="Hello world."
06
07   # 使用 source 命令调用脚本
08   source ./output.sh
</pre>
</div>
      <p class="kindle-cn-para-left">在上面的代码中，第5行定义了名称为message的变量，第8行使用source命令调用output.sh脚本。</p>
      <p class="kindle-cn-para-left">上述程序的执行结果如下；</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# ./ex13-8.sh</span>
Hello world.
</pre>
</div>
<p class="kindle-cn-para-left">从上面的执行结果可以得知，尽管变量在ex13-8.sh脚本中定义，但是仍然可以在output.sh脚本中访问。之所以会这样，是因为在第8行中使用source命令调用output.sh脚本，这使得output.sh脚本与ex13-8.sh脚本在同一个Shell进程中执行，所以两者的变量可以相互访问。</p>
      <p class="kindle-cn-para-left">除了上面介绍的临时文件和命名管道之外，还有许多方法可以实现子Shell向父Shell传递数据，例如命令替换和使用eval命令等，读者可以根据自己的实际情况来选择适当的通信机制。</p>
      <h2 class="kindle-cn-heading1" id="sub319"><a href="part0004.html#toc319" class="calibre8">13.2　进程处理</a>
      </h2>
<p class="kindle-cn-para-left">在进行系统维护的过程中，经常会遇到进程和作业的处理问题。通过Shell编程，用户可以对进程和作业进行有效地管理。本节介绍如何通过Shell进行进程的相关操作。</p>
      <h3 class="kindle-cn-heading2" id="sub320"><a href="part0004.html#toc320" class="calibre8">13.2.1　什么是进程</a>
      </h3>
      <p class="kindle-cn-para-left">在讲到进程的时候，不得不提到另外一个概念，即程序。通常情况下，我们所讲的程序是计算机指令的集合，是一个静态的概念。</p>
      <p class="kindle-cn-para-left">进程是指在自身的虚拟地址空间运行的一个单独的程序，是程序执行的基本单元。进程会利用处理器资源、内存资源，并且进行各种I/O操作，从而完成某项指定的任务。因此，进程是一个动态的概念。</p>
      <p class="kindle-cn-para-left">进程与程序是有区别的，进程不是程序，虽然它由程序产生。程序只是一个静态的指令集合，不占系统的运行资源；而进程是一个随时都可能发生变化的、动态的、使用系统运行资源的程序。而且一个程序可以启动多个进程。</p>
      <p class="kindle-cn-para-left">大致来说，Linux中的进程可以分为以下3类。</p>
<ul class="kindle-cn-ul-square">
      <li class="calibre5">交互进程：由Shell启动的进程。交互进程既可以在前台运行，也可以在后台运行。</li>
       <li class="calibre5">批处理进程：进程序列。</li>
      <li class="calibre5">监控进程：又称为守护进程，Linux的服务进程，在后台运行。</li>
</ul>
      <h3 class="kindle-cn-heading2" id="sub321"><a href="part0004.html#toc321" class="calibre8">13.2.2　通过脚本监控进程</a>
      </h3>
<p class="kindle-cn-para-left">通常情况下，通过脚本来监控进程可以收到事半功倍的效果。例如，在绝大部分的Web服务器都是运行在Linux上面。但是在某些情况下，Web服务器的进程httpd会由于某些错误而退出，导致用户的网站不能访问。而系统管理员则不可能会24小时都在监控Web服务器的运行状态。</p>
      <p class="kindle-cn-para-left">在这种情况下，系统管理员可以编写一个脚本来监控Web服务器进程是否存在，如果不存在，则重新启动该服务进程。</p>
      <p class="kindle-cn-para-left">【<span class="kindle-cn-bold">例13-9</span>】演示Web服务器监控脚本的编写方法，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">01   #----------------------------/chapter13/ex13-9.sh------------------
02   #!/bin/bash
03
04   #Apache httpd 进程监控 shell
05
06   # 启动服务命令
07   RESTART="/sbin/service httpd start"
08
09   #pgrep 命令路径
10   PGREP="/usr/bin/pgrep"
11
12   #Apache Web 服务器的进程名称
13   HTTPD="httpd"
14
15   # 查找 httpd 进程
16   $PGREP ${HTTPD} &amp;&gt;/dev/null
17   # 如果没有找到，则重新启动服务
18   if [ $? -ne 0 ]
19   then
20      $RESTART
21   fi
</pre>
</div>
      <p class="kindle-cn-para-left">在上面的代码中，第7行定义了重新启动Apache Web访问进程的命令；第10行定义了pgrep命令的路径；第13行定义了Apache Web服务的进程名称；第16行使用pgrep命令判断Apache Web服务进程是否存在，其中的重定向是为了避免pgrep命令输出信息。第18行通过系统变量$?判断第16行的pgrep命令是否执行成功，如果不等于0，则表示不存在Apache Web服务进程，从而在第20行启动该服务进程。</p>
      <p class="kindle-cn-para-left">为了能够周期性地检查Apache Web服务的进程是否存在，用户可以使用crontab任务计划来定期执行上面的脚本，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">*/30 * * * * /root/chapter13/ex13-9.sh &gt;/dev/null 2&gt;&amp;1
</pre>
</div>
      <p class="kindle-cn-para-left">以上代码表示每30秒钟执行一次/root/chapter13/ex13-9.sh脚本。</p>
      <h3 class="kindle-cn-heading2" id="sub322"><a href="part0004.html#toc322" class="calibre8">13.2.3　作业控制</a>
      </h3>
      <p class="kindle-cn-para-left">通常情况下，我们将一个正在执行的进程称为一个作业。尽管进程和作业密不可分，但是进程和作业是有区别的。一般来说，作业是针对用户而言的，是用户为了完成某项任务而启动的进程，一个作业可以包含一个进程，也可以包含多个进程，这些进程之间相互协作，共同完成任务。而进程则是针对操作系统而言的，是操作系统中程序执行的基本单位。</p>
      <p class="kindle-cn-para-left">例如，下面的一组名称可以称为一个作业，其功能是在ls命令的手册中查找包含long字符串的文本行，然后将匹配结果传递给more命令，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# man ls | grep long | more</span>
       Mandatory arguments to long options are  mandatory  for  short  options
              across  -x, commas -m, horizontal -x, long -l, single-column -1,
              in a long listing, don’t print group names
       -l     use a long listing format
              with  -l, show times using style STYLE: full-iso, long-iso, iso,
</pre>
</div>
<p class="kindle-cn-para-left">尽管上面的一组命令构成了一个作业，但是实际上Shell会启动3个进程，分别执行man、grep及more命令。</p>
      <p class="kindle-cn-para-left">作业控制指的是用户控制正在运行的组成作业的进程的行为。在前面已经介绍过，用户可以在命令的后面附加&amp;操作符，使该命令在后台执行。另外，用户还可以将作业中的某个进程挂起，暂停其执行，然后在某个时刻继续执行该进程。</p>
      <p class="kindle-cn-para-left">【<span class="kindle-cn-bold">例13-10</span>】演示将进程进行前后台切换的方法，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">01   #---------------------------/chapter13/ex13-10.sh------------------
02   #! /bin/bash
03
04   # 使得当前进程休眠 10 秒钟
05   sleep 10
</pre>
</div>
      <p class="kindle-cn-para-left">上面的代码比较简单，其中第5行使用sleep命令使当前进程休眠10秒钟。sleep命令的功能是使进程休眠指定的时间，其基本语法如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">sleep number[suffix]
</pre>
</div>
      <p class="kindle-cn-para-left">其中，参数number表示要休眠的时间长度，参数suffix表示时间单位，默认为秒，可以是秒、分钟、小时及天等，这些时间单位分别使用s、m、h及d等字母表示。</p>
      <p class="kindle-cn-para-left">在命令行中输入以下命令执行ex13-10.sh：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# ./ex13-10.sh &amp;</span>
[1] 28426
</pre>
</div>
      <p class="kindle-cn-para-left">当用户输入以上命令，并且按回车键之后，Shell会将脚本放在后台执行，并且立即返回两个数字，其中方括号中的数字为作业号，后面的数字为执行脚本的进程ID。由于脚本在后台执行，所以用户可以同时执行其他的操作。当作业执行完成之后，会在命令行给出以下提示：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">[1]+  Done                    ./ex13-10.sh
</pre>
</div>
      <p class="kindle-cn-para-left">以上提示包括作业号、状态，以及所执行的命令。</p>
      <p class="kindle-cn-para-left">在执行前台作业的时候，用户可以通过组合键Ctrl+Z使当前的作业挂起，例如，用户在命令行中输入以下命令：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# vi demo.sh</span>
</pre>
</div>
<p class="kindle-cn-para-left">当按回车键之后，Shell会调用vi编辑器，出现一个全屏编辑窗口。在编辑文本的过程中，用户需要暂时退出vi编辑器，执行其他的命令。则可以先切换到vi的命令状态，然后按下Ctrl+Z组合键。此时，Shell会给出以下提示信息：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">[1]+  Stopped                 vi demo.sh
[root@linux chapter13]#
</pre>
</div>
      <p class="kindle-cn-para-left">以上信息告诉用户，作业号为1的作业已经被挂起，其命令为vi demo.sh。接下来就是Shell的命令提示符。</p>
<p class="kindle-cn-para-left">当用户处理完其他任务之后，可以使用fg命令将后台执行的作业切换到前台执行，如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# fg</span>
</pre>
</div>
      <p class="kindle-cn-para-left">fg是一个内部命令，其作用是将后台的作业移至前台执行，其基本语法如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">fg [jobspec]
</pre>
</div>
<p class="kindle-cn-para-left">在上面的语法中，参数jobspec用来指定要切换的作业，可以是作业号或者是作业的命令名称等。如果省略该参数，则表示将作业号为1的作业移至前台。因此，如果当前系统中只有一个作业在后台运行，则可以直接使用fg命令，省略其他参数。如表13-3所示，列出了fg命令中用来指定作业的方法。</p>
<p class="kindle-cn-caption"><span class="kindle-cn-bold">表13-3　fg命令中指定作业的方法</span></p>
<table cellspacing="0" class="kindle-cn-table-body">
        <tr class="calibre13">
          <td class="kindle-cn-table-th">方　法</td>
          <td class="kindle-cn-table-th1">说　明</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">%n</td>
          <td class="kindle-cn-table-dg">n为整数，表示作业号</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">%string</td>
          <td class="kindle-cn-table-dg">以字符串string开头的命令所对应的作业</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">%?string</td>
          <td class="kindle-cn-table-dg">包含字符串string的命令所对应的作业</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">%+或者%%</td>
          <td class="kindle-cn-table-dg">最近提交的一个作业</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">%-</td>
          <td class="kindle-cn-table-dg">倒数第2个提交的作业</td>
        </tr>
      </table>
      <p class="kindle-cn-para-left">例如，以下命令将以字符串vi开头的命令所对应的作业移至前台：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# fg %vi</span>
</pre>
</div>
      <p class="kindle-cn-para-left">前台作业和后台作业在功能上并没有什么不同。只是前台作业会占用终端窗口，用户不能同时执行其他命令，必须等待前台作业完成才能执行其他操作。而后台作业则不占用终端窗口，用户可以同时执行其他操作。</p>
      <p class="kindle-cn-para-left">Shell提供了另外一个内部命令jobs，用来查看正在后台执行的作业的列表，其基本语法如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">jobs [options]
</pre>
</div>
      <p class="kindle-cn-para-left">其中，options表示jobs命令的选项，常用的选项有-l和-p，前者显示作业的详细信息，后者只显示作业的进程ID。例如，下面的jobs命令列出当前用户的所有后台作业：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# jobs</span>
[1]     Stopped                 vi demo.sh
[2]-    Stopped                 vi demo1.sh
[3]+    Stopped                 vi demo2.sh
</pre>
</div>
<p class="kindle-cn-para-left">通过上面的结果，可以得知当前用户有3个后台作业在执行。默认情况下，jobs命令的输出结果包含3列，第1列为作业号，如果在某个作业号后面有一个加号+，则表示当前作业为默认作业。也就是说，在使用fg命令管理作业的时候，如果没有指定作业，则会将作业号后面附加+符号的作业移至前台。</p>
      <p class="kindle-cn-para-left">另外，在上面的输出结果中，编号为2的作业号后面有一个减号-，该符号表示当前作业为即将成为默认作业的作业。也就是说，当含有+符号的作业退出之后，含有-符号的做作业将成为默认作业。</p>
      <p class="kindle-cn-para-left">对于其他的作业，作业号后面是一个空格。对于同一个用户来说，只能有一个作业使用+符号标识，也只能有一个作业使用-符号标识。</p>
      <p class="kindle-cn-para-left">在jobs命令的输出结果中，第2列为作业的执行状态。如表13-4所示，列出了几种常见的作业状态。</p>
<p class="kindle-cn-caption"><span class="kindle-cn-bold">表13-4　作业状态</span></p>
<table cellspacing="0" class="kindle-cn-table-body">
        <tr class="calibre13">
          <td class="kindle-cn-table-th">状　态</td>
          <td class="kindle-cn-table-th1">说　明</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">Running</td>
          <td class="kindle-cn-table-dg">该作业并没有被挂起，而是正在运行</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">Done</td>
          <td class="kindle-cn-table-dg">该作业已经完成并返回退出状态码0</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">Done (code)</td>
          <td class="kindle-cn-table-dg">该作业已经正常完成和退出，并返回指定的非0退出状态码code。状态码使用十进制表示</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">Stopped</td>
          <td class="kindle-cn-table-dg">该作业被挂起</td>
        </tr>
      </table>
      <p class="kindle-cn-para-left">用户可以使用disown命令来删除作业列表中的作业，该命令的基本语法如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">disown [jobspec ...]
</pre>
</div>
      <p class="kindle-cn-para-left">在上面的语法中，参数jobspec表示要从列表中删除的作业。与fd命令一样，用户可以使用作业号、进程ID，以及命令名称等方法来指定作业。</p>
      <p class="kindle-cn-para-left">下面的例子演示了disown命令的使用方法。首先执行3个vi命令，并且使其在后台执行，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# vi demo.sh &amp;</span>
[1] 30880
<span class="kindle-cn-bold">[root@linux chapter13]# vi demo1.sh &amp;</span>
[2] 30881
[1]+    Stopped               vi demo.sh
<span class="kindle-cn-bold">[root@linux chapter13]# vi demo2.sh &amp;</span>
[3] 30890
[2]+    Stopped               vi demo1.sh
<span class="kindle-cn-bold">[root@linux chapter13]# jobs</span>
[1]     Stopped               vi demo.sh
[2]-  Stopped                 vi demo1.sh
[3]+    Stopped               vi demo2.sh
</pre>
</div>
      <p class="kindle-cn-para-left">通过最后的jobs命令，可以得知当前有3个作业被挂起。其中3号作业为默认作业， 2号作业为即将成为默认作业的作业。接下来的命令将1号作业删除，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# disown %1</span>
-bash: warning: deleting stopped job 1 with process group 30880
<span class="kindle-cn-bold">[root@linux chapter13]# jobs</span>
[2]-  Stopped                 vi demo1.sh
[3]+    Stopped              vi demo2.sh
</pre>
</div>
      <p class="kindle-cn-para-left">在上面的命令中，disown使用%1作为参数。执行完该命令之后，Shell给出一条警告信息，告诉用户1号作业已经被删除。然后通过jobs命令再次输出作业列表，发现只剩下2号和3号作业。</p>
      <p class="kindle-cn-para-hang"><img class="kindle-cn-inline-image1" alt="img" src="../images/00005.jpeg"/><span class="kindle-cn-bold">注意：</span><span class="cnother">删除作业还可以使用kill命令，该命令将在信号中介绍。</span></p>
      <h3 class="kindle-cn-heading2" id="sub322a"><a href="part0004.html#toc322a" class="calibre8">13.2.4　信号与trap命令</a>
      </h3>
<p class="kindle-cn-para-left">信号在Linux系统中是非常重要的一种通信机制。信号在软件层次上模拟了硬件中断机制。因此，简单地讲，信号即软件中断。在Linux系统中，用户可以通过kill命令给某个进程发送一个特定的信号，也可以通过键盘发送一些信号，比如组合键CTRL+C可能触发SIGINT信号，而组合键CTRL+\可能触发SIGQUIT信号等。</p>
      <p class="kindle-cn-para-left">绝大部分的系统都预定义了一些信号，用户可以通过kill命令的-l选项来列出当前系统支持的信号，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# kill -l</span>
 1) SIGHUP       2) SIGINT     3) SIGQUIT      4) SIGILL        5) SIGTRAP
 6) SIGABRT      7) SIGBUS     8) SIGFPE        9) SIGKILL      10) SIGUSR1
11) SIGSEGV      12) SIGUSR2    13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD    18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN      22) SIGTTOU    23) SIGURG      24) SIGXCPU     25) SIGXFSZ
…
</pre>
</div>
      <p class="kindle-cn-para-hang"><img class="kindle-cn-inline-image1" alt="img" src="../images/00005.jpeg"/><span class="kindle-cn-bold">注意：</span><span class="cnother">用户还可以通过man 7 signal命令查看有关信号的帮助手册。</span></p>
      <p class="kindle-cn-para-left">如表13-5所示，列出了常用的信号及其涵义。</p>
<p class="kindle-cn-caption"><span class="kindle-cn-bold">表13-5　常用信号及其涵义</span></p>
<table cellspacing="0" class="kindle-cn-table-body">
        <tr class="calibre13">
          <td class="kindle-cn-table-th">信　号</td>
          <td class="kindle-cn-table-th1">值</td>
          <td class="kindle-cn-table-th1">涵义</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">SIGHUP</td>
          <td class="kindle-cn-table-dg">1</td>
          <td class="kindle-cn-table-dg">终端挂起或者控制进程终止</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">SIGINT</td>
          <td class="kindle-cn-table-dg">2</td>
          <td class="kindle-cn-table-dg">键盘中断</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">SIGQUIT</td>
          <td class="kindle-cn-table-dg">3</td>
          <td class="kindle-cn-table-dg">键盘的退出键被按下</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">SIGABRT</td>
          <td class="kindle-cn-table-dg">6</td>
          <td class="kindle-cn-table-dg">由abort(3)发出的退出指令</td>
        </tr>
        <tr class="calibre13">
          <td class="kindle-cn-table-dg1a">SIGKILL</td>
          <td class="kindle-cn-table-dg">9</td>
          <td class="kindle-cn-table-dg">立即结束进程</td>
        </tr>
      </table>
      <p class="kindle-cn-para-left">表13-5只列出了最常用的几个信号，关于其他的信号，读者可以参考Linux的帮助手册。对于管理员来说，最常用的信号是SIGKILL，该信号用来立即结束进程的运行。SIGKILL信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。</p>
      <p class="kindle-cn-para-left">前面讲过，删除作业的方法除了使用disown命令之外，还可以使用kill命令。kill的基本语法如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">kill [-s signal|-p] [--] pid...
</pre>
</div>
      <p class="kindle-cn-para-left">在上面的语法中，-s选项用来指定要发送的信号，-p选项表示只是打印指定名称的进程的进程ID，不发送信号，参数pid表示某个特定的进程ID。</p>
      <p class="kindle-cn-para-left">下面的例子演示了如何使用kill命令来删除作业。首先使用jobs命令列出当前的作业列表，如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# jobs</span>
[2]-  Stopped                 vi demo1.sh
[3]+  Stopped                 vi demo2.sh
<span class="kindle-cn-bold">[root@linux chapter13]# jobs -p</span>
30881
30890
</pre>
</div>
      <p class="kindle-cn-para-left">由于kill需要指定进程ID，所以还要使用jobs命令的-p选项输出作业的进程ID。现在想要删除进程ID为30881的作业，可以使用以下命令：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# kill -s 9 30881</span>
</pre>
</div>
      <p class="kindle-cn-para-left">以上命令表示向进程ID为30881的进程发送值为9的信号，即SIGKILL信号。执行完以上命令之后，再次使用jobs命令查看作业列表，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# jobs</span>
[2]-    Killed                vi demo1.sh
[3]+    Stopped               vi demo2.sh
<span class="kindle-cn-bold">[root@linux chapter13]# jobs</span>
[3]+    Stopped               vi demo2.sh
</pre>
</div>
<p class="kindle-cn-para-left">从上面的执行结果可以得知，2号作业的状态为Killed，表示该作业已经退出。在接下来的作业列表中，该项作业已经消失。</p>
<p class="kindle-cn-para-hang"><img class="kindle-cn-inline-image1" alt="img" src="../images/00005.jpeg"/><span class="kindle-cn-bold">注意：</span><span class="cnother">kill命令中的-s可以省略，直接使用数字，例如上面的命令可以直接写成kill -9 30881。</span></p>
<p class="kindle-cn-para-left">对于有些信号，进程会有默认的响应动作，而有些信号，进程可能直接会忽略，当然，用户还可以对某些信号设定专门的处理函数。在Shell程序中，用户可以通过trap命令来设定响应某个信号的动作。trap是一个内部命令，其基本语法如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">trap [[arg] sigspec ...]
</pre>
</div>
      <p class="kindle-cn-para-left">在上面的语法中，参数arg表示信号响应操作的函数，sigspec表示特定的信号。</p>
      <p class="kindle-cn-para-left">【<span class="kindle-cn-bold">例13-11</span>】演示trap命令的使用方法，代码如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12">01   #---------------------------/chapter13/ex13-11.sh------------------
02   #! /bin/bash
03
04   # 定义响应函数
05   function signal_handler {
06      echo "Good bye."
07   }
08
09   # 绑定响应函数
10   trap signal_handler 0
</pre>
</div>
<p class="kindle-cn-para-left">在上面的代码中，第5～7行定义了响应信号的函数，该函数比较简单，只是输出一行消息。第10行通过trap命令将函数与信号0绑定。信号0是一个特殊的信号，在POSIX标准中，把0定义为空信号，当进程退出时会触发该信号。因此用户经常使用该信号来判断一个特定的进程是否存在。</p>
      <p class="kindle-cn-para-left">该程序的执行结果如下：</p>
<div class="kindle-cn-xinying">
<pre class="calibre12"><span class="kindle-cn-bold">[root@linux chapter13]# ./ex13-11.sh</span>
Good bye.
</pre>
</div>
      <h2 class="kindle-cn-heading1" id="sub323"><a href="part0004.html#toc323" class="calibre8">13.3　小结</a>
      </h2>
<p class="kindle-cn-para-left">本章详细介绍了子Shell以及进程和作业管理，主要包括什么是子Shell、内部命令、外部命令、圆括号结构、子Shell中的变量作用域、把子Shell中的变量值传回父Shell、什么是进程、创建单进程脚本、作业控制，以及信号与trap命令。重点在于掌握子Shell的基本概念、什么情况下会使用子Shell、子Shell的变量及其作用域、父子Shell的数据传递，以及作业的控制等相关知识。在下一章中将介绍Shell脚本调试技术。</p>
    </div>
  

  </div>

  
  <div class="calibreToc">
    <h2><a href="../../pARZf2.html"> Table of contents</a></h2>
     <div>
  <ul>
    <li>
      <a href="part0001.html#UGI0-55ac501d2b9f4bebb0296c8a16b339b4">内容简介</a>
    </li>
    <li>
      <a href="part0003.html#2RHM0-55ac501d2b9f4bebb0296c8a16b339b4">前言</a>
    </li>
    <li>
      <a href="part0004.html#3Q280-55ac501d2b9f4bebb0296c8a16b339b4">目录</a>
    </li>
    <li>
      <a href="part0005.html#chapter2">第1篇　认识Shell编程</a>
      <ul>
        <li>
          <a href="part0006.html#chapter3">第1章　Shell入门基础</a>
          <ul>
            <li>
              <a href="part0006.html#sub4">1.1　为什么学习和使用Shell编程</a>
            </li>
            <li>
              <a href="part0006.html#sub5">1.2　什么是Shell</a>
              <ul>
                <li>
                  <a href="part0006.html#sub6">1.2.1　Shell的起源</a>
                </li>
                <li>
                  <a href="part0006.html#sub7">1.2.2　Shell的功能</a>
                </li>
                <li>
                  <a href="part0006.html#sub8">1.2.3　Shell的分类</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0006.html#sub9">1.3　作为程序设计语言的Shell</a>
              <ul>
                <li>
                  <a href="part0006.html#sub10">1.3.1　交互式程序</a>
                </li>
                <li>
                  <a href="part0006.html#sub11">1.3.2　创建脚本</a>
                </li>
                <li>
                  <a href="part0006.html#sub12">1.3.3　把脚本设置为可执行</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0006.html#sub13">1.4　向脚本传递参数</a>
              <ul>
                <li>
                  <a href="part0006.html#sub14">1.4.1　Shell脚本的参数</a>
                </li>
                <li>
                  <a href="part0006.html#sub15">1.4.2　参数扩展</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0006.html#sub16">1.5　第一个Shell程序：Hello，Bash Shell！</a>
              <ul>
                <li>
                  <a href="part0006.html#sub17">1.5.1　Shell脚本的基本元素</a>
                </li>
                <li>
                  <a href="part0006.html#sub18">1.5.2　指定命令解读器</a>
                </li>
                <li>
                  <a href="part0006.html#sub19">1.5.3　Shell脚本中的注释和风格</a>
                </li>
                <li>
                  <a href="part0006.html#sub20">1.5.4　如何执行Shell程序</a>
                </li>
                <li>
                  <a href="part0006.html#sub21">1.5.5　Shell程序的退出状态</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0006.html#sub22">1.6　小结</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="part0007.html#chapter23">第2章　Shell编程环境的搭建</a>
          <ul>
            <li>
              <a href="part0007.html#sub24">2.1　在不同的操作系统上搭建Shell编程环境</a>
              <ul>
                <li>
                  <a href="part0007.html#sub25">2.1.1　在Windows上搭建Shell编程环境</a>
                </li>
                <li>
                  <a href="part0007.html#sub26">2.1.2　在Linux上搭建Shell编程环境</a>
                </li>
                <li>
                  <a href="part0007.html#sub27">2.1.3　在FreeBSD上搭建Shell编程环境</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0007.html#sub28">2.2　编辑器的选择</a>
              <ul>
                <li>
                  <a href="part0007.html#sub29">2.2.1　图形化编辑器</a>
                </li>
                <li>
                  <a href="part0007.html#sub30">2.2.2　vi（vim）编辑器</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0007.html#sub31">2.3　系统环境的搭建</a>
              <ul>
                <li>
                  <a href="part0007.html#sub32">2.3.1　Shell配置文件</a>
                </li>
                <li>
                  <a href="part0007.html#sub33">2.3.2　命令别名</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0007.html#sub34">2.4　小结</a>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <a href="part0008.html#chapter35">第2篇　Shell编程基础</a>
      <ul>
        <li>
          <a href="part0009.html#chapter36">第3章　变量和引用</a>
          <ul>
            <li>
              <a href="part0009.html#sub37">3.1　深入认识变量</a>
              <ul>
                <li>
                  <a href="part0009.html#sub38">3.1.1　什么是变量</a>
                </li>
                <li>
                  <a href="part0009.html#sub39">3.1.2　变量的命名</a>
                </li>
                <li>
                  <a href="part0009.html#sub40">3.1.3　变量的类型</a>
                </li>
                <li>
                  <a href="part0009.html#sub41">3.1.4　变量的定义</a>
                </li>
                <li>
                  <a href="part0009.html#sub42">3.1.5　变量和引号</a>
                </li>
                <li>
                  <a href="part0009.html#sub43">3.1.6　变量的作用域</a>
                </li>
                <li>
                  <a href="part0009.html#sub43a">3.1.7　系统变量</a>
                </li>
                <li>
                  <a href="part0009.html#sub44">3.1.8　环境变量</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0009.html#sub45">3.2　变量赋值和清空</a>
              <ul>
                <li>
                  <a href="part0009.html#sub46">3.2.1　变量赋值</a>
                </li>
                <li>
                  <a href="part0009.html#sub47">3.2.2　引用变量的值</a>
                </li>
                <li>
                  <a href="part0009.html#sub48">3.2.3　清除变量</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0009.html#sub49">3.3　引用和替换</a>
              <ul>
                <li>
                  <a href="part0009.html#sub50">3.3.1　引用</a>
                </li>
                <li>
                  <a href="part0009.html#sub51">3.3.2　全引用</a>
                </li>
                <li>
                  <a href="part0009.html#sub52">3.3.3　部分引用</a>
                </li>
                <li>
                  <a href="part0009.html#sub53">3.3.4　命令替换</a>
                </li>
                <li>
                  <a href="part0009.html#sub53a">3.3.5　转义</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0009.html#sub54">3.4　小结</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="part0010.html#chapter55">第4章　条件测试和判断语句</a>
          <ul>
            <li>
              <a href="part0010.html#sub56">4.1　条 件 测 试</a>
              <ul>
                <li>
                  <a href="part0010.html#sub57">4.1.1　条件测试的基本语法</a>
                </li>
                <li>
                  <a href="part0010.html#sub58">4.1.2　字符串测试</a>
                </li>
                <li>
                  <a href="part0010.html#sub59">4.1.3　整数测试</a>
                </li>
                <li>
                  <a href="part0010.html#sub60">4.1.4　文件测试</a>
                </li>
                <li>
                  <a href="part0010.html#sub61">4.1.5　逻辑操作符</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0010.html#sub62">4.2　条件判断语句</a>
              <ul>
                <li>
                  <a href="part0010.html#sub63">4.2.1　使用简单的if语句进行条件判断</a>
                </li>
                <li>
                  <a href="part0010.html#sub64">4.2.2　使用if else语句进行流程控制</a>
                </li>
                <li>
                  <a href="part0010.html#sub65">4.2.3　使用if elif语句进行多条件判断</a>
                </li>
                <li>
                  <a href="part0010.html#sub66">4.2.4　使用exit语句退出程序</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0010.html#sub67">4.3　多条件判断语句case</a>
              <ul>
                <li>
                  <a href="part0010.html#sub68">4.3.1　多条件判断语句case的基本语法</a>
                </li>
                <li>
                  <a href="part0010.html#sub69">4.3.2　利用case语句处理选项参数</a>
                </li>
                <li>
                  <a href="part0010.html#sub70">4.3.3　利用case语句处理用户输入</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0010.html#sub71">4.4　运 算 符</a>
              <ul>
                <li>
                  <a href="part0010.html#sub72">4.4.1　算术运算符</a>
                </li>
                <li>
                  <a href="part0010.html#sub73">4.4.2　位运算符</a>
                </li>
                <li>
                  <a href="part0010.html#sub74">4.4.3　自增/自减运算符</a>
                </li>
                <li>
                  <a href="part0010.html#sub75">4.4.4　数字常量的进制</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0010.html#sub76">4.5　小结</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="part0011.html#chapter77">第5章　循 环 结 构</a>
          <ul>
            <li>
              <a href="part0011.html#sub78">5.1　步进循环语句for</a>
              <ul>
                <li>
                  <a href="part0011.html#sub79_1">5.1.1　带列表的for循环语句</a>
                </li>
                <li>
                  <a href="part0011.html#sub79">5.1.2　不带列表的for循环语句</a>
                </li>
                <li>
                  <a href="part0011.html#sub80">5.1.3　类C风格的for循环语句</a>
                </li>
                <li>
                  <a href="part0011.html#sub81">5.1.4　使用for循环语句处理数组</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0011.html#sub82">5.2　until循环语句</a>
              <ul>
                <li>
                  <a href="part0011.html#sub83">5.2.1　until语句的基本语法</a>
                </li>
                <li>
                  <a href="part0011.html#sub84">5.2.2　利用until语句批量增加用户</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0011.html#sub85">5.3　while循环语句</a>
              <ul>
                <li>
                  <a href="part0011.html#sub86">5.3.1　while语句的基本语法</a>
                </li>
                <li>
                  <a href="part0011.html#sub87">5.3.2　通过计数器控制while循环结构</a>
                </li>
                <li>
                  <a href="part0011.html#sub88">5.3.3　通过结束标记控制while循环结构</a>
                </li>
                <li>
                  <a href="part0011.html#sub89">5.3.4　理解while语句与until语句的区别</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0011.html#sub90">5.4　嵌 套 循 环</a>
            </li>
            <li>
              <a href="part0011.html#sub91">5.5　利用break和continue语句控制循环</a>
              <ul>
                <li>
                  <a href="part0011.html#sub92">5.5.1　利用break语句控制循环</a>
                </li>
                <li>
                  <a href="part0011.html#sub93">5.5.2　利用continue语句控制循环</a>
                </li>
                <li>
                  <a href="part0011.html#sub94">5.5.3　分析break语句和continue语句的区别</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0011.html#sub95">5.6　小结</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="part0012.html#chapter96">第6章　函数</a>
          <ul>
            <li>
              <a href="part0012.html#sub97">6.1　函数</a>
              <ul>
                <li>
                  <a href="part0012.html#sub98">6.1.1　什么是函数</a>
                </li>
                <li>
                  <a href="part0012.html#sub99">6.1.2　函数的定义</a>
                </li>
                <li>
                  <a href="part0012.html#sub100">6.1.3　函数的调用</a>
                </li>
                <li>
                  <a href="part0012.html#sub101">6.1.4　函数链接</a>
                </li>
                <li>
                  <a href="part0012.html#sub102">6.1.5　函数的返回值</a>
                </li>
                <li>
                  <a href="part0012.html#sub103">6.1.6　函数和别名</a>
                </li>
                <li>
                  <a href="part0012.html#sub104">6.1.7　再议全局变量和局部变量</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0012.html#sub105">6.2　函 数 参 数</a>
              <ul>
                <li>
                  <a href="part0012.html#sub106">6.2.1　含有参数的函数的调用方法</a>
                </li>
                <li>
                  <a href="part0012.html#sub107">6.2.2　获取函数参数的个数</a>
                </li>
                <li>
                  <a href="part0012.html#sub108">6.2.3　通过位置变量接收参数值</a>
                </li>
                <li>
                  <a href="part0012.html#sub109">6.2.4　移动位置参数</a>
                </li>
                <li>
                  <a href="part0012.html#sub110">6.2.5　通过getopts接收函数参数</a>
                </li>
                <li>
                  <a href="part0012.html#sub111">6.2.6　间接参数传递</a>
                </li>
                <li>
                  <a href="part0012.html#sub112">6.2.7　通过全局变量传递数据</a>
                </li>
                <li>
                  <a href="part0012.html#sub113">6.2.8　传递数组参数</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0012.html#sub114">6.3　函数库文件</a>
              <ul>
                <li>
                  <a href="part0012.html#sub115">6.3.1　函数库文件的定义</a>
                </li>
                <li>
                  <a href="part0012.html#sub116">6.3.2　函数库文件的调用</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0012.html#sub117">6.4　递 归 函 数</a>
            </li>
            <li>
              <a href="part0012.html#sub118">6.5　小结</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="part0013.html#chapter119">第7章　数组</a>
          <ul>
            <li>
              <a href="part0013.html#sub120">7.1　定 义 数 组</a>
              <ul>
                <li>
                  <a href="part0013.html#sub121">7.1.1　通过指定元素值来定义数组</a>
                </li>
                <li>
                  <a href="part0013.html#sub122">7.1.2　通过declare语句定义数组</a>
                </li>
                <li>
                  <a href="part0013.html#sub123">7.1.3　通过元素值集合定义数组</a>
                </li>
                <li>
                  <a href="part0013.html#sub124">7.1.4　通过键值对定义数组</a>
                </li>
                <li>
                  <a href="part0013.html#sub125">7.1.5　数组和普通变量</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0013.html#sub126">7.2　数组的赋值</a>
              <ul>
                <li>
                  <a href="part0013.html#sub127">7.2.1　按索引为元素赋值</a>
                </li>
                <li>
                  <a href="part0013.html#sub128">7.2.2　通过集合为数组赋值</a>
                </li>
                <li>
                  <a href="part0013.html#sub129">7.2.3　在数组末尾追加新元素</a>
                </li>
                <li>
                  <a href="part0013.html#sub130">7.2.4　通过循环为数组元素赋值</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0013.html#sub131">7.3　访 问 数 组</a>
              <ul>
                <li>
                  <a href="part0013.html#sub132">7.3.1　访问第1个数组元素</a>
                </li>
                <li>
                  <a href="part0013.html#sub133">7.3.2　通过下标访问数组元素</a>
                </li>
                <li>
                  <a href="part0013.html#sub134">7.3.3　计算数组的长度</a>
                </li>
                <li>
                  <a href="part0013.html#sub135">7.3.4　通过循环遍历数组元素</a>
                </li>
                <li>
                  <a href="part0013.html#sub136">7.3.5　引用所有的数组元素</a>
                </li>
                <li>
                  <a href="part0013.html#sub137">7.3.6　以切片方式获取部分数组元素</a>
                </li>
                <li>
                  <a href="part0013.html#sub138">7.3.7　数组元素的替换</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0013.html#sub139">7.4　删 除 数 组</a>
              <ul>
                <li>
                  <a href="part0013.html#sub140">7.4.1　删除指定数组元素</a>
                </li>
                <li>
                  <a href="part0013.html#sub141">7.4.2　删除整个数组</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0013.html#sub142">7.5　数组的其他操作</a>
              <ul>
                <li>
                  <a href="part0013.html#sub143">7.5.1　复制数组</a>
                </li>
                <li>
                  <a href="part0013.html#sub144">7.5.2　连接数组</a>
                </li>
                <li>
                  <a href="part0013.html#sub145">7.5.3　加载文件内容到数组</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0013.html#sub146">7.6　小结</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="part0014.html#chapter147">第8章　正则表达式</a>
          <ul>
            <li>
              <a href="part0014.html#sub148">8.1　什么是正则表达式</a>
              <ul>
                <li>
                  <a href="part0014.html#sub149">8.1.1　为什么使用正则表达式</a>
                </li>
                <li>
                  <a href="part0014.html#sub150">8.1.2　如何学习正则表达式</a>
                </li>
                <li>
                  <a href="part0014.html#sub150a">8.1.3　如何实践正则表达式</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0014.html#sub151">8.2　正则表达式基础</a>
              <ul>
                <li>
                  <a href="part0014.html#sub152">8.2.1　正则表达式的原理</a>
                </li>
                <li>
                  <a href="part0014.html#sub153">8.2.2　基本正则表达式</a>
                </li>
                <li>
                  <a href="part0014.html#sub154">8.2.3　扩展正则表达式</a>
                </li>
                <li>
                  <a href="part0014.html#sub155">8.2.4　Perl正则表达式</a>
                </li>
                <li>
                  <a href="part0014.html#sub156">8.2.5　正则表达式字符集</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0014.html#sub157">8.3　正则表达式应用</a>
              <ul>
                <li>
                  <a href="part0014.html#sub158">8.3.1　匹配单个字符</a>
                </li>
                <li>
                  <a href="part0014.html#sub159">8.3.2　匹配多个字符</a>
                </li>
                <li>
                  <a href="part0014.html#sub160">8.3.3　匹配字符串的开头或者结尾</a>
                </li>
                <li>
                  <a href="part0014.html#sub161">8.3.4　运算符优先级</a>
                </li>
                <li>
                  <a href="part0014.html#sub162">8.3.5　子表达式</a>
                </li>
                <li>
                  <a href="part0014.html#sub163">8.3.6　通配符</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0014.html#sub164">8.4　grep命令</a>
              <ul>
                <li>
                  <a href="part0014.html#sub165">8.4.1　grep命令的基本语法</a>
                </li>
                <li>
                  <a href="part0014.html#sub166">8.4.2　grep命令族简介</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0014.html#sub167">8.5　小结</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="part0015.html#chapter168">第9章　基本文本处理</a>
          <ul>
            <li>
              <a href="part0015.html#sub169">9.1　使用echo命令输出文本</a>
              <ul>
                <li>
                  <a href="part0015.html#sub170">9.1.1　显示普通字符串</a>
                </li>
                <li>
                  <a href="part0015.html#sub171">9.1.2　显示转义字符</a>
                </li>
                <li>
                  <a href="part0015.html#sub172">9.1.3　显示变量</a>
                </li>
                <li>
                  <a href="part0015.html#sub173">9.1.4　换行和不换行</a>
                </li>
                <li>
                  <a href="part0015.html#sub174">9.1.5　显示命令执行结果</a>
                </li>
                <li>
                  <a href="part0015.html#sub175">9.1.6　echo命令执行结果的重定向</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0015.html#sub176">9.2　文本的格式化输出</a>
              <ul>
                <li>
                  <a href="part0015.html#sub177">9.2.1　使用UNIX制表符</a>
                </li>
                <li>
                  <a href="part0015.html#sub178">9.2.2　使用fold命令格式化行</a>
                </li>
                <li>
                  <a href="part0015.html#sub179">9.2.3　使用fmt命令格式化段落</a>
                </li>
                <li>
                  <a href="part0015.html#sub180">9.2.4　使用rev命令反转字符顺序</a>
                </li>
                <li>
                  <a href="part0015.html#sub181">9.2.5　使用pr命令格式化文本页</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0015.html#sub182">9.3　使用sort命令对文本排序</a>
              <ul>
                <li>
                  <a href="part0015.html#sub183">9.3.1　sort命令的基本用法</a>
                </li>
                <li>
                  <a href="part0015.html#sub184">9.3.2　使用单个关键字排序</a>
                </li>
                <li>
                  <a href="part0015.html#sub185">9.3.3　根据指定的列排序</a>
                </li>
                <li>
                  <a href="part0015.html#sub186">9.3.4　根据关键字降序排序</a>
                </li>
                <li>
                  <a href="part0015.html#sub187">9.3.5　数值列的排序</a>
                </li>
                <li>
                  <a href="part0015.html#sub188">9.3.6　自定义列分隔符</a>
                </li>
                <li>
                  <a href="part0015.html#sub189">9.3.7　删除重复的行</a>
                </li>
                <li>
                  <a href="part0015.html#sub190">9.3.8　根据多个关键字排序</a>
                </li>
                <li>
                  <a href="part0015.html#sub191">9.3.9　使用sort命令合并文件</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0015.html#sub192">9.4　文本的统计</a>
              <ul>
                <li>
                  <a href="part0015.html#sub193">9.4.1　输出含有行号的文本行</a>
                </li>
                <li>
                  <a href="part0015.html#sub194">9.4.2　统计行数</a>
                </li>
                <li>
                  <a href="part0015.html#sub195">9.4.3　统计单词数和字符数</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0015.html#sub196">9.5　使用cut命令选取文本列</a>
              <ul>
                <li>
                  <a href="part0015.html#sub197">9.5.1　cut命令及其语法</a>
                </li>
                <li>
                  <a href="part0015.html#sub198">9.5.2　选择指定的文本列</a>
                </li>
                <li>
                  <a href="part0015.html#sub199">9.5.3　选择指定数量的字符</a>
                </li>
                <li>
                  <a href="part0015.html#sub200">9.5.4　排除不包含列分隔符的行</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0015.html#sub201">9.6　使用paste命令拼接文本列</a>
              <ul>
                <li>
                  <a href="part0015.html#sub202">9.6.1　paste命令及其语法</a>
                </li>
                <li>
                  <a href="part0015.html#sub203">9.6.2　自定义列分隔符</a>
                </li>
                <li>
                  <a href="part0015.html#sub204">9.6.3　拼接指定的文本列</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0015.html#sub205">9.7　使用join命令联接文本列</a>
              <ul>
                <li>
                  <a href="part0015.html#sub206">9.7.1　join命令及其语法</a>
                </li>
                <li>
                  <a href="part0015.html#sub207">9.7.2　指定联接关键字列</a>
                </li>
                <li>
                  <a href="part0015.html#sub208">9.7.3　内联接文本文件</a>
                </li>
                <li>
                  <a href="part0015.html#sub209">9.7.4　左联接文本文件</a>
                </li>
                <li>
                  <a href="part0015.html#sub210">9.7.5　右联接文本文件</a>
                </li>
                <li>
                  <a href="part0015.html#sub211">9.7.6　全联接文本文件</a>
                </li>
                <li>
                  <a href="part0015.html#sub212">9.7.7　自定义输出列</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0015.html#sub213">9.8　使用tr命令替换文件内容</a>
              <ul>
                <li>
                  <a href="part0015.html#sub214">9.8.1　tr命令及其语法</a>
                </li>
                <li>
                  <a href="part0015.html#sub215">9.8.2　去除重复出现的字符</a>
                </li>
                <li>
                  <a href="part0015.html#sub216">9.8.3　删除空行</a>
                </li>
                <li>
                  <a href="part0015.html#sub216a">9.8.4　大小写转换</a>
                </li>
                <li>
                  <a href="part0015.html#sub216b">9.8.5　删除指定字符</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0015.html#sub217">9.9　小结</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="part0016.html#chapter218">第10章　流 编 辑</a>
          <ul>
            <li>
              <a href="part0016.html#sub219">10.1　sed命令及其语法</a>
              <ul>
                <li>
                  <a href="part0016.html#sub220">10.1.1　sed命令以及语法</a>
                </li>
                <li>
                  <a href="part0016.html#sub221">10.1.2　sed命令的工作方式</a>
                </li>
                <li>
                  <a href="part0016.html#sub222">10.1.3　使用行号定位文本行</a>
                </li>
                <li>
                  <a href="part0016.html#sub223">10.1.4　使用正则表达式定位文本行</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0016.html#sub224">10.2　sed命令的常用操作</a>
              <ul>
                <li>
                  <a href="part0016.html#sub225">10.2.1　sed编辑命令基本语法</a>
                </li>
                <li>
                  <a href="part0016.html#sub226">10.2.2　选择文本</a>
                </li>
                <li>
                  <a href="part0016.html#sub227">10.2.3　替换文本</a>
                </li>
                <li>
                  <a href="part0016.html#sub228">10.2.4　删除文本</a>
                </li>
                <li>
                  <a href="part0016.html#sub229">10.2.5　追加文本</a>
                </li>
                <li>
                  <a href="part0016.html#sub230">10.2.6　插入文本</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0016.html#sub231">10.3　组 合 命 令</a>
              <ul>
                <li>
                  <a href="part0016.html#sub232">10.3.1　使用-e选项执行多个子命令</a>
                </li>
                <li>
                  <a href="part0016.html#sub233">10.3.2　使用分号执行多个子命令</a>
                </li>
                <li>
                  <a href="part0016.html#sub234">10.3.3　对一个地址使用多个子命令</a>
                </li>
                <li>
                  <a href="part0016.html#sub235">10.3.4　sed脚本文件</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0016.html#sub236">10.4　小结</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="part0017.html#chapter237">第11章　文本处理利器awk命令</a>
          <ul>
            <li>
              <a href="part0017.html#sub238">11.1　awk入门</a>
              <ul>
                <li>
                  <a href="part0017.html#sub239">11.1.1　awk的功能</a>
                </li>
                <li>
                  <a href="part0017.html#sub240">11.1.2　awk命令的基本语法</a>
                </li>
                <li>
                  <a href="part0017.html#sub241">11.1.3　awk的工作流程</a>
                </li>
                <li>
                  <a href="part0017.html#sub242">11.1.4　执行awk程序的几种方式</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0017.html#sub246">11.2　awk的模式匹配</a>
              <ul>
                <li>
                  <a href="part0017.html#sub247">11.2.1　关系表达式</a>
                </li>
                <li>
                  <a href="part0017.html#sub248">11.2.2　正则表达式</a>
                </li>
                <li>
                  <a href="part0017.html#sub249">11.2.3　混合模式</a>
                </li>
                <li>
                  <a href="part0017.html#sub250">11.2.4　区间模式</a>
                </li>
                <li>
                  <a href="part0017.html#sub243">11.2.5　BEGIN模式</a>
                </li>
                <li>
                  <a href="part0017.html#sub251">11.2.6　END模式</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0017.html#sub252">11.3　变量</a>
              <ul>
                <li>
                  <a href="part0017.html#sub253">11.3.1　变量的定义和引用</a>
                </li>
                <li>
                  <a href="part0017.html#sub254">11.3.2　系统内置变量</a>
                </li>
                <li>
                  <a href="part0017.html#sub255">11.3.3　记录分隔符和字段分隔符</a>
                </li>
                <li>
                  <a href="part0017.html#sub256">11.3.4　记录和字段的引用</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0017.html#sub257">11.4　运算符和表达式</a>
              <ul>
                <li>
                  <a href="part0017.html#sub258">11.4.1　算术运算符</a>
                </li>
                <li>
                  <a href="part0017.html#sub259">11.4.2　赋值运算符</a>
                </li>
                <li>
                  <a href="part0017.html#sub260">11.4.3　条件运算符</a>
                </li>
                <li>
                  <a href="part0017.html#sub261">11.4.4　逻辑运算符</a>
                </li>
                <li>
                  <a href="part0017.html#sub262">11.4.5　关系运算符</a>
                </li>
                <li>
                  <a href="part0017.html#sub263">11.4.6　其他运算符</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0017.html#sub264">11.5　函数</a>
              <ul>
                <li>
                  <a href="part0017.html#sub265">11.5.1　字符串函数</a>
                </li>
                <li>
                  <a href="part0017.html#sub266">11.5.2　算术函数</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0017.html#sub267">11.6　数组</a>
              <ul>
                <li>
                  <a href="part0017.html#sub268">11.6.1　数组的定义和赋值</a>
                </li>
                <li>
                  <a href="part0017.html#sub269">11.6.2　遍历数组</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0017.html#sub270">11.7　流 程 控 制</a>
              <ul>
                <li>
                  <a href="part0017.html#sub271">11.7.1　if语句</a>
                </li>
                <li>
                  <a href="part0017.html#sub272">11.7.2　while语句</a>
                </li>
                <li>
                  <a href="part0017.html#sub273">11.7.3　do…while语句</a>
                </li>
                <li>
                  <a href="part0017.html#sub274">11.7.4　for语句</a>
                </li>
                <li>
                  <a href="part0017.html#sub275">11.7.5　break语句</a>
                </li>
                <li>
                  <a href="part0017.html#sub276">11.7.6　continue语句</a>
                </li>
                <li>
                  <a href="part0017.html#sub277">11.7.7　next语句</a>
                </li>
                <li>
                  <a href="part0017.html#sub278">11.7.8　exit语句</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0017.html#sub279">11.8　awk程序的格式化输出</a>
              <ul>
                <li>
                  <a href="part0017.html#sub280">11.8.1　基本print语句</a>
                </li>
                <li>
                  <a href="part0017.html#sub281">11.8.2　格式化输出printf语句</a>
                </li>
                <li>
                  <a href="part0017.html#sub282">11.8.3　使用sprintf()函数生成格式化字符串</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0017.html#sub283">11.9　awk的程序与Shell的交互</a>
              <ul>
                <li>
                  <a href="part0017.html#sub284">11.9.1　通过管道实现与Shell的交换</a>
                </li>
                <li>
                  <a href="part0017.html#sub285">11.9.2　通过system函数实现与Shell的交互</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0017.html#sub286">11.10　小结</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="part0018.html#chapter287">第12章　文件的操作</a>
          <ul>
            <li>
              <a href="part0018.html#sub288">12.1　文件</a>
              <ul>
                <li>
                  <a href="part0018.html#sub289">12.1.1　列出文件</a>
                </li>
                <li>
                  <a href="part0018.html#sub290">12.1.2　文件类型</a>
                </li>
                <li>
                  <a href="part0018.html#sub291">12.1.3　文件的权限</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0018.html#sub292">12.2　查 找 文 件</a>
              <ul>
                <li>
                  <a href="part0018.html#sub293">12.2.1　find命令以及语法</a>
                </li>
                <li>
                  <a href="part0018.html#sub294">12.2.2　find命令：路径</a>
                </li>
                <li>
                  <a href="part0018.html#sub295">12.2.3　find命令：测试</a>
                </li>
                <li>
                  <a href="part0018.html#sub296">12.2.4　find命令：使用!运算符对测试求反</a>
                </li>
                <li>
                  <a href="part0018.html#sub297">12.2.5　find命令：处理文件权限错误信息</a>
                </li>
                <li>
                  <a href="part0018.html#sub298">12.2.6　find命令：动作</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0018.html#sub299">12.3　比 较 文 件</a>
              <ul>
                <li>
                  <a href="part0018.html#sub300">12.3.1　使用comm比较文件</a>
                </li>
                <li>
                  <a href="part0018.html#sub301">12.3.2　使用diff比较文件</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0018.html#sub302">12.4　文件描述符</a>
              <ul>
                <li>
                  <a href="part0018.html#sub303">12.4.1　什么是文件描述符</a>
                </li>
                <li>
                  <a href="part0018.html#sub304">12.4.2　标准输入、标准输出和标准错误</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0018.html#sub305">12.5　重 定 向</a>
              <ul>
                <li>
                  <a href="part0018.html#sub306">12.5.1　输出重定向（覆盖）</a>
                </li>
                <li>
                  <a href="part0018.html#sub307">12.5.2　输出重定向（追加）</a>
                </li>
                <li>
                  <a href="part0018.html#sub308">12.5.3　输入重定向</a>
                </li>
                <li>
                  <a href="part0018.html#sub309">12.5.4　当前文档</a>
                </li>
                <li>
                  <a href="part0018.html#sub310">12.5.5　重定向两个文件描述符</a>
                </li>
                <li>
                  <a href="part0018.html#sub311">12.5.6　使用exec命令分配文件描述符</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0018.html#sub312">12.6　小结</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="part0019.html#chapter313">第13章　子Shell与进程处理</a>
          <ul>
            <li>
              <a href="part0019.html#sub314">13.1　子Shell</a>
              <ul>
                <li>
                  <a href="part0019.html#sub315">13.1.1　什么是子Shell</a>
                </li>
                <li>
                  <a href="part0019.html#sub316">13.1.2　内部命令、保留字和外部命令</a>
                </li>
                <li>
                  <a href="part0019.html#sub317">13.1.3　在子Shell中执行命令</a>
                </li>
                <li>
                  <a href="part0019.html#sub318">13.1.4　把子Shell中的变量值传回父Shell</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0019.html#sub319">13.2　进 程 处 理</a>
              <ul>
                <li>
                  <a href="part0019.html#sub320">13.2.1　什么是进程</a>
                </li>
                <li>
                  <a href="part0019.html#sub321">13.2.2　通过脚本监控进程</a>
                </li>
                <li>
                  <a href="part0019.html#sub322">13.2.3　作业控制</a>
                </li>
                <li>
                  <a href="part0019.html#sub322a">13.2.4　信号与trap命令</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0019.html#sub323">13.3　小结</a>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <a href="part0020.html#chapter324">第3篇　Shell编程实战</a>
      <ul>
        <li>
          <a href="part0021.html#chapter325">第14章　Shell脚本调试技术</a>
          <ul>
            <li>
              <a href="part0021.html#sub326">14.1　Shell脚本中的常见错误</a>
              <ul>
                <li>
                  <a href="part0021.html#sub327">14.1.1　常见语法错误</a>
                </li>
                <li>
                  <a href="part0021.html#sub328">14.1.2　常见逻辑错误</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0021.html#sub329">14.2　Shell脚本调试技术</a>
              <ul>
                <li>
                  <a href="part0021.html#sub330">14.2.1　使用echo命令调试脚本</a>
                </li>
                <li>
                  <a href="part0021.html#sub331">14.2.2　使用trap命令调试Shell脚本</a>
                </li>
                <li>
                  <a href="part0021.html#sub332">14.2.3　使用tee命令调试Shell脚本</a>
                </li>
                <li>
                  <a href="part0021.html#sub333">14.2.4　使用调试钩子调试Shell脚本</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0021.html#sub334">14.3　小结</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="part0022.html#chapter335">第15章　利用Shell脚本解决实际问题</a>
          <ul>
            <li>
              <a href="part0022.html#sub336">15.1　编写系统服务脚本</a>
              <ul>
                <li>
                  <a href="part0022.html#sub337">15.1.1　系统启动过程</a>
                </li>
                <li>
                  <a href="part0022.html#sub338">15.1.2　运行级别</a>
                </li>
                <li>
                  <a href="part0022.html#sub339">15.1.3　服务脚本的基本语法</a>
                </li>
                <li>
                  <a href="part0022.html#sub340">15.1.4　编写MySQL服务脚本</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0022.html#sub341">15.2　通过脚本管理Apache服务器日志</a>
              <ul>
                <li>
                  <a href="part0022.html#sub342">15.2.1　Apache以及日志文件简介</a>
                </li>
                <li>
                  <a href="part0022.html#sub343">15.2.2　备份归档文件名生成函数</a>
                </li>
                <li>
                  <a href="part0022.html#sub344">15.2.3　过期日志备份归档函数</a>
                </li>
                <li>
                  <a href="part0022.html#sub345">15.2.4　过期日志删除函数</a>
                </li>
                <li>
                  <a href="part0022.html#sub346">15.2.5　日志归档主程序</a>
                </li>
                <li>
                  <a href="part0022.html#sub347">15.2.6　定时运行日志归档脚本</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="part0022.html#sub348">15.3　小结</a>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <a href="part0023.html#chapter336">附录CD</a>
    </li>
  </ul>
</div>


  </div>
  

  <div class="calibreEbNav">
    
      <a href="part0018.html" class="calibreAPrev">previous page</a>
    

    <a href="../../pARZf2.html" class="calibreAHome"> start</a>

    
      <a href="part0020.html" class="calibreANext"> next page</a>
    
  </div>

</div>

</body>
</html>
